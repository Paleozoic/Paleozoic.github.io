---
title: 设计模式
date: 2017-05-07 19:16:17
categories: [设计模式]
tags: [设计模式]
typora-root-url: ..
---
<Excerpt in index | 首页摘要>
设计模式的学习，巩固面向对象的开发知识，力求写出更加优雅的代码。<!-- more -->
<The rest of contents | 余下全文>
# 写在前面
设计模式的运用个人觉得不用刻意，以解决需求为前提。需求是驱动技术的根本。
在业务需求不稳定的时候，设计模式的使用更加需要谨慎衡量。
设计模式应用在业务需求的发展十分明确的场景下，比如重构或者写基础框架。
设计模式模式是遵循软件设计七大原则的典范，而面向对象的多态、继承与封装是他们实现的基础。

# 面向对象
## 封装
抽象现实模型（现实对象的行为和属性）为类，隐藏用户不关心的属性和方法，暴露用户需要的属性和方法。
## 继承
子类通过继承父类，扩展甚至修改父类的功能，并复用父类的代码。表达的是IS-A关系。
## 多态
- 定义：同一父类型的引用在不同运行时的情况下表现出不同的子对象行为形式。
- 解析：多态发生条件如下：
  * 存在继承
  * 子类重写父类方法
  * 父类引用指向子类对象
    父类引用指向子类对象，父类引用调用的方法会是其子类对象复写的父类方法。
- 例子：
```java
List<String> list = new ArrayList<String>();
list.add("Hello,World!");
//在这里父类引用list指向子类对象ArrayList，父类引用调用add方法，实际上调用的是子类ArrayList的add方法。
```

# 软件设计原则
## 开闭原则(Open-Closed Principle, OCP)
- 定义：软件实体(classes,modules,functions,etc.)应当对扩展开放，对修改关闭。
- 解析：即在软件设计中，需求变更或者业务的增加，不应修改原有的代码，影响原来的业务逻辑；而是通过增加代码或者配置的形式来解决新需求。
- 例子：Spring的Bean注入，只需要修改配置文件，便可以注入新的Bean，且不影响原来的Bean。典型地通过工厂模式遵循了开闭原则。这里的依赖注入还遵循了控制翻转的思想，将原本应在代码里实现的对象依赖暴露给配置文件（调用方）控制。

## 里氏代换原则(Liskov Substitution Principle,LSP)
- 定义：如果是S是T的子类，则S的实例可以透明地转换为T类型。（多态）
- 解析：在语言层面，Java早已支持多态。而在代码设计层面，应遵循：
  * 子类尽量不覆盖父类的非抽象方法。（因为此举会破坏父类制定的行为，然而事实上并不严格遵守此要求）
  * 子类方法的返回类型应比父类更为严格。（如果父类返回List，那么子类就返回ArrayList）
- 例子：`List<String> list = new ArrayList<String>();`

## 依赖倒置原则(Dependence Inversion Principle,DIP)
- 定义：高层模块不应依赖低层模块。两者都应依赖其抽象。抽象不依赖具体。具体依赖于抽象。
- 解析：面向接口编程，编程时应高屋建瓴，先制定接口约束实现类的行为规范，再去写具体的实现类。
- 例子：一般代码里面写服务层，都是写XXXService和XXXServiceImpl，这便是面向接口编程。不过这里的依赖并非指继承，Service之间的依赖通过组合来体现。

## 接口隔离原则(Interface Segregation Principle,ISP)
- 定义：客户端不应依赖它们不需要使用的接口，类之间的依赖应尽可能建立在最小的接口上。
- 解析：程序开发中，接口应该尽量细化，避免冗余的接口实现。
- 例子：`public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable`，ArrayList的多接口实现便是接口细化的结果。

## 合成/聚合复用原则(Composite/Aggregate Reuse Principle,CARP)
- 定义：通过组合/继承实现代码复用。
- 解析：尽量通过组合HAS-A实现代码复用，除非有十分明确的继承IS-A语义（代码上则体现为是否需要使用多态），才使用继承实现代码复用。
- 例子：轮子组合为汽车，轮子是汽车的内部属性（组合），奔驰继承自汽车，汽车可以派生出奔驰、宝马一类的汽车。

## 迪米特法则(Law of Demeter,LoD)
- 定义：最少知道原则，调用者尽量少地调用被调用者的接口来实现自己的功能。通俗总结如下：
  * 每个单元应有限度地知道其他单元，其只局限于与当前单元紧密联系的单元
  * 每个单元都应只和熟人说话，不要和陌生人说话
  * 只和你的直系朋友说话
- 解析：服务端暴露给客户端的接口应该尽可能简单（或者说统一的对外接口），使得服务端修改代码后，而不影响服务端的业务逻辑。
- 例子：实际开发中，通常通过private、protected之类的关键字控制代码的可见性，目的便是遵循最少知道原则；在提供对外API时，也常常封装统一的对外接口，通过传参来确定内部服务的复杂调用逻辑，而不是将调用逻辑暴露给客户端（有问题优先内部解决）。

## 单一职责原则(Simple responsibility pinciple,SRP)
- 定义：每个模块/类只负责单一的业务功能，遵循高内聚的思想。
- 解析：额，略。
- 例子：日常开发中，我们早已不自觉的遵循了这个原则，比如服务层和控制器层，会用package去分类。而每个业务功能的Service，通过类再次划分。实现了低耦合和高内聚。

# UML类图

- 实现关系：代码体现为实现接口，或者继承抽象类。
- 组合关系：HAS-A。小汽车含有轮胎和发动机。并且整体不存在，则组合个体不存在。（整体强依赖）即：小汽车不存在了，便没有了轮胎和发动机。
- 聚合关系：学生聚合成班级，班级由学生组成。即使整体不存在，但个体依然存在。（整体弱依赖）即：班级不存在了，学生依然存在。
- 泛化关系：理解为继承关系，IS-A。SUV继承自小汽车，SUV是小汽车。
- 关联关系：表示一种“强关联”的关系，比如学生和身份证。代码体现一般为成员变量，身份证是学生的成员变量。
- 依赖关系：依赖关系一般体现在运行时。在代码中体现为被依赖者作为参数给依赖着。例如：`student.rideBike(bike);`

![UML类图](/resources/img/design_patterns/UML类图.png)



# 创建型设计模式

## 单例模式



# 结构型设计模式



# 行为型设计模式

## 责任链模式

Chain of Responsibility，做过工作流的话，可以看到两者的相似之处。

- successor：成功处理后的下一个处理者。
- handleRequest()：处理客户端/下级Handler的请求的方法
- Handler：抽象处理者接口
- ConcreteHandler：具体处理者，实现了Handler接口

![设计模式_行为型模式_责任链模式_UML图](/resources/img/design_patterns/设计模式_行为型模式_责任链模式_UML图.png)

# 引用
[图说设计模式](http://design-patterns.readthedocs.io/zh_CN/latest/index.html)
